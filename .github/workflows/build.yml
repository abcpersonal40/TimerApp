name: TitanChart Pro Flutter Final Build

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.19.0'

      - name: Create Flutter Project & Add Dependencies
        run: |
          rm -rf ./* .target
          flutter create --org com.titanchart --project-name titanchart_pro .
          # Adding dependencies for Time, Notifications, and Local Storage
          flutter pub add webview_flutter:^4.7.0
          flutter pub add flutter_foreground_task:^6.5.0
          flutter pub add flutter_local_notifications:^17.0.0
          flutter pub add intl:^0.19.0
          flutter pub add shared_preferences:^2.2.2

      - name: Setup Android Manifest
        run: |
          cat > android/app/src/main/AndroidManifest.xml <<EOF
          <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.titanchart.titanchart_pro">
              <uses-permission android:name="android.permission.INTERNET"/>
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
              <uses-permission android:name="android.permission.VIBRATE" />
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>

              <application
                  android:label="TitanChart Pro"
                  android:name="\${applicationName}"
                  android:icon="@mipmap/ic_launcher">
                  
                  <meta-data
                      android:name="flutterEmbedding"
                      android:value="2" />

                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:theme="@style/LaunchTheme"
                      android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|screenLayout|uiMode"
                      android:hardwareAccelerated="true"
                      android:windowSoftInputMode="adjustResize">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN"/>
                          <category android:name="android.intent.category.LAUNCHER"/>
                      </intent-filter>
                  </activity>
                  
                  <service 
                      android:name="com.pravera.flutter_foreground_task.service.ForegroundService"
                      android:foregroundServiceType="dataSync"
                      android:exported="false" />
              </application>
          </manifest>
          EOF

      - name: Setup Flutter Main Code (Advanced Logic)
        run: |
          cat > lib/main.dart <<EOF
          import 'dart:async';
          import 'dart:isolate';
          import 'dart:ui';
          import 'package:flutter/material.dart';
          import 'package:flutter_foreground_task/flutter_foreground_task.dart';
          import 'package:webview_flutter/webview_flutter.dart';
          import 'package:flutter_local_notifications/flutter_local_notifications.dart';
          import 'package:intl/intl.dart';

          // --- GLOBAL STATE SIMULATION (For Single File Arch) ---
          // In a real app, use a database. Here we use static memory for the service.
          class AppState {
            static List<Map<String, dynamic>> timers = []; // {id, label, remaining, isRunning}
            static Map<String, dynamic> stopwatch = {'running': false, 'elapsed': 0};
            static List<Map<String, dynamic>> alarms = []; // {time, message, enabled}
          }

          final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();

          void main() async {
            WidgetsFlutterBinding.ensureInitialized();
            await _initNotifications();
            runApp(const TitanApp());
          }

          Future<void> _initNotifications() async {
            const AndroidInitializationSettings initializationSettingsAndroid =
                AndroidInitializationSettings('@mipmap/ic_launcher');
            const InitializationSettings initializationSettings =
                InitializationSettings(android: initializationSettingsAndroid);
            await flutterLocalNotificationsPlugin.initialize(initializationSettings);
          }

          @pragma('vm:entry-point')
          void startCallback() {
            FlutterForegroundTask.setTaskHandler(MyTaskHandler());
          }

          class MyTaskHandler extends TaskHandler {
            Timer? _timer;
            
            // To communicate back to UI
            void _sendUpdate(SendPort? sendPort) {
               sendPort?.send('UPDATE'); // Simple signal to refresh UI
            }

            @override
            Future<void> onStart(DateTime timestamp, SendPort? sendPort) async {
              _timer = Timer.periodic(const Duration(seconds: 1), (timer) async {
                bool updateNotification = false;
                String notifText = "";

                // 1. Handle Timers
                List<String> activeTimers = [];
                for (var t in AppState.timers) {
                  if (t['isRunning'] == true && t['remaining'] > 0) {
                    t['remaining']--;
                    updateNotification = true;
                    activeTimers.add("\${t['label']}: \${_formatTime(t['remaining'])}");
                    
                    if (t['remaining'] == 0) {
                      t['isRunning'] = false;
                      _showAlarmNotification("Timer Done!", "Timer \${t['label']} has finished.");
                    }
                  }
                }

                // 2. Handle Stopwatch
                if (AppState.stopwatch['running']) {
                  AppState.stopwatch['elapsed']++;
                  updateNotification = true;
                  notifText += " | SW: \${_formatTime(AppState.stopwatch['elapsed'])}";
                }

                // 3. Handle Alarms
                DateTime now = DateTime.now();
                for (var alarm in AppState.alarms) {
                  if (alarm['enabled']) {
                    DateTime scheduled = DateTime.parse(alarm['time']);
                    if (now.year == scheduled.year && now.month == scheduled.month && 
                        now.day == scheduled.day && now.hour == scheduled.hour && 
                        now.minute == scheduled.minute && now.second == 0) {
                        _showAlarmNotification("Alarm!", alarm['message']);
                        alarm['enabled'] = false; // Trigger once
                    }
                  }
                }

                // 4. Update Notification Bar
                if (updateNotification) {
                  String status = activeTimers.join(" | ");
                  if (status.isEmpty && AppState.stopwatch['running']) status = "Stopwatch Running";
                  if (status.isNotEmpty) {
                     FlutterForegroundTask.updateService(
                      notificationTitle: 'TitanChart Pro Tools',
                      notificationText: status + notifText,
                    );
                    _sendUpdate(sendPort);
                  }
                }
              });
            }

            String _formatTime(int seconds) {
              int h = seconds ~/ 3600;
              int m = (seconds % 3600) ~/ 60;
              int s = seconds % 60;
              return "\${h > 0 ? '\$h:' : ''}\${m.toString().padLeft(2, '0')}:\${s.toString().padLeft(2, '0')}";
            }

            Future<void> _showAlarmNotification(String title, String body) async {
              const AndroidNotificationDetails androidPlatformChannelSpecifics =
                  AndroidNotificationDetails('titan_alarm', 'Titan Alarms',
                      importance: Importance.max, priority: Priority.high, playSound: true);
              const NotificationDetails platformChannelSpecifics =
                  NotificationDetails(android: androidPlatformChannelSpecifics);
              await flutterLocalNotificationsPlugin.show(
                  DateTime.now().millisecond, title, body, platformChannelSpecifics);
            }

            @override
            void onRepeatEvent(DateTime timestamp, SendPort? sendPort) {
              // Not used, handled in Timer.periodic
            }

            @override
            Future<void> onDestroy(DateTime timestamp, SendPort? sendPort) async {
              _timer?.cancel();
            }

            @override
            void onButtonPressed(String id) {
              if (id == 'stop_all') {
                for (var t in AppState.timers) t['isRunning'] = false;
                AppState.stopwatch['running'] = false;
                FlutterForegroundTask.updateService(notificationTitle: 'TitanChart Pro', notificationText: 'All Stopped');
              }
            }
            
            @override
            void onNotificationPressed() {
              FlutterForegroundTask.launchApp();
            }
          }

          class TitanApp extends StatefulWidget {
            const TitanApp({super.key});
            @override State<TitanApp> createState() => _TitanAppState();
          }

          class _TitanAppState extends State<TitanApp> with SingleTickerProviderStateMixin {
            late TabController _tabController;
            ReceivePort? _receivePort;

            @override
            void initState() {
              super.initState();
              _tabController = TabController(length: 4, vsync: this); // Chart, Timer, SW, Alarm
              _initForeground();
              
              // Listen for updates from service
               _receivePort = FlutterForegroundTask.receivePort;
               _receivePort?.listen((message) {
                 if (message == 'UPDATE') setState(() {});
               });
            }

            void _initForeground() {
              FlutterForegroundTask.init(
                androidNotificationOptions: AndroidNotificationOptions(
                  channelId: 'titan_tools',
                  channelName: 'Titan Tools',
                  channelImportance: NotificationChannelImportance.LOW,
                  priority: NotificationPriority.LOW,
                  iconData: const NotificationIconData(resType: ResourceType.mipmap, resPrefix: ResourcePrefix.ic, name: 'launcher'),
                  buttons: [
                    const NotificationButton(id: 'stop_all', text: 'STOP ALL'),
                  ],
                ),
                iosNotificationOptions: const IOSNotificationOptions(),
                foregroundTaskOptions: const ForegroundTaskOptions(
                  interval: 1000,
                  isOnceEvent: false,
                  autoRunOnBoot: true,
                  allowWakeLock: true,
                ),
              );
            }
            
            void _startService() async {
              if (!await FlutterForegroundTask.isRunningService) {
                FlutterForegroundTask.startService(
                  notificationTitle: 'TitanChart Pro',
                  notificationText: 'Tools Ready',
                  callback: startCallback,
                );
              }
            }

            @override
            Widget build(BuildContext context) {
              return MaterialApp(
                debugShowCheckedModeBanner: false,
                theme: ThemeData.dark().copyWith(
                  scaffoldBackgroundColor: const Color(0xFF0B0E14),
                  appBarTheme: const AppBarTheme(backgroundColor: Color(0xFF161B22)),
                ),
                home: WithForegroundTask(
                  child: Scaffold(
                    appBar: AppBar(
                      title: const Text("TitanChart Pro"),
                      bottom: TabBar(
                        controller: _tabController,
                        indicatorColor: const Color(0xFF238636),
                        tabs: const [
                          Tab(icon: Icon(Icons.show_chart), text: "Chart"),
                          Tab(icon: Icon(Icons.timer), text: "Timers"),
                          Tab(icon: Icon(Icons.watch_later), text: "Stopwatch"),
                          Tab(icon: Icon(Icons.alarm), text: "Alarms"),
                        ],
                      ),
                    ),
                    body: TabBarView(
                      controller: _tabController,
                      children: [
                        const ChartView(),
                        TimerView(onUpdate: () { _startService(); setState((){}); }),
                        StopwatchView(onUpdate: () { _startService(); setState((){}); }),
                        AlarmView(onUpdate: () { _startService(); setState((){}); }),
                      ],
                    ),
                  ),
                ),
              );
            }
          }

          // --- 1. CHART VIEW (WebView) ---
          class ChartView extends StatefulWidget {
            const ChartView({super.key});
            @override State<ChartView> createState() => _ChartViewState();
          }
          class _ChartViewState extends State<ChartView> {
            late final WebViewController _controller;
            @override
            void initState() {
              super.initState();
              _controller = WebViewController()
                ..setJavaScriptMode(JavaScriptMode.unrestricted)
                ..setBackgroundColor(const Color(0xFF0B0E14))
                ..loadHtmlString(_getHtml());
            }
            @override Widget build(BuildContext context) => WebViewWidget(controller: _controller);
            String _getHtml() => """
              <!DOCTYPE html><html><body style="background:#0b0e14;color:white;display:flex;align-items:center;justify-content:center;height:90vh;font-family:sans-serif;">
              <h1>TitanChart Dashboard</h1></body></html>""";
          }

          // --- 2. TIMER VIEW ---
          class TimerView extends StatelessWidget {
            final VoidCallback onUpdate;
            const TimerView({super.key, required this.onUpdate});

            @override
            Widget build(BuildContext context) {
              return Scaffold(
                floatingActionButton: FloatingActionButton(
                  backgroundColor: const Color(0xFF238636),
                  child: const Icon(Icons.add),
                  onPressed: () => _addTimer(context),
                ),
                body: ListView.builder(
                  itemCount: AppState.timers.length,
                  itemBuilder: (ctx, i) {
                    final t = AppState.timers[i];
                    return Card(
                      color: const Color(0xFF161B22),
                      margin: const EdgeInsets.all(10),
                      child: ListTile(
                        leading: Icon(Icons.timer, color: t['isRunning'] ? Colors.green : Colors.grey),
                        title: Text(t['label'], style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                        subtitle: Text(_formatSeconds(t['remaining']), style: const TextStyle(color: Color(0xFF58A6FF), fontSize: 24, fontFamily: 'monospace')),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            IconButton(
                              icon: Icon(t['isRunning'] ? Icons.pause : Icons.play_arrow, color: Colors.white),
                              onPressed: () { t['isRunning'] = !t['isRunning']; onUpdate(); },
                            ),
                            IconButton(
                              icon: const Icon(Icons.delete, color: Colors.red),
                              onPressed: () { AppState.timers.removeAt(i); onUpdate(); },
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              );
            }

            void _addTimer(BuildContext context) {
              TextEditingController secCtrl = TextEditingController(text: "60");
              TextEditingController lblCtrl = TextEditingController(text: "Timer \${AppState.timers.length + 1}");
              showDialog(context: context, builder: (ctx) => AlertDialog(
                backgroundColor: const Color(0xFF161B22),
                title: const Text("Add Timer", style: TextStyle(color: Colors.white)),
                content: Column(mainAxisSize: MainAxisSize.min, children: [
                  TextField(controller: lblCtrl, decoration: const InputDecoration(labelText: "Label"), style: const TextStyle(color: Colors.white)),
                  TextField(controller: secCtrl, keyboardType: TextInputType.number, decoration: const InputDecoration(labelText: "Seconds"), style: const TextStyle(color: Colors.white)),
                ]),
                actions: [
                  TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("Cancel")),
                  TextButton(onPressed: () {
                    AppState.timers.add({'id': DateTime.now().toString(), 'label': lblCtrl.text, 'remaining': int.parse(secCtrl.text), 'isRunning': false});
                    onUpdate();
                    Navigator.pop(ctx);
                  }, child: const Text("Add", style: TextStyle(color: Colors.green))),
                ],
              ));
            }
            
            String _formatSeconds(int seconds) {
               int m = seconds ~/ 60; int s = seconds % 60;
               return "\${m.toString().padLeft(2, '0')}:\${s.toString().padLeft(2, '0')}";
            }
          }

          // --- 3. STOPWATCH VIEW ---
          class StopwatchView extends StatelessWidget {
            final VoidCallback onUpdate;
            const StopwatchView({super.key, required this.onUpdate});

            @override
            Widget build(BuildContext context) {
              int elapsed = AppState.stopwatch['elapsed'];
              bool isRunning = AppState.stopwatch['running'];
              
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(_formatSeconds(elapsed), style: const TextStyle(fontSize: 80, fontFamily: 'monospace', color: Color(0xFF58A6FF))),
                    const SizedBox(height: 30),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        ElevatedButton(
                          style: ElevatedButton.styleFrom(backgroundColor: isRunning ? Colors.orange : Colors.green, padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 20)),
                          onPressed: () {
                             AppState.stopwatch['running'] = !isRunning;
                             onUpdate();
                          },
                          child: Text(isRunning ? "PAUSE" : "START", style: const TextStyle(fontSize: 20)),
                        ),
                        const SizedBox(width: 20),
                        ElevatedButton(
                          style: ElevatedButton.styleFrom(backgroundColor: Colors.red, padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 20)),
                          onPressed: () {
                             AppState.stopwatch['running'] = false;
                             AppState.stopwatch['elapsed'] = 0;
                             onUpdate();
                          },
                          child: const Text("RESET", style: TextStyle(fontSize: 20)),
                        ),
                      ],
                    )
                  ],
                ),
              );
            }
            String _formatSeconds(int seconds) {
               int h = seconds ~/ 3600; int m = (seconds % 3600) ~/ 60; int s = seconds % 60;
               return "\${h.toString().padLeft(2, '0')}:\${m.toString().padLeft(2, '0')}:\${s.toString().padLeft(2, '0')}";
            }
          }

          // --- 4. ALARM VIEW ---
          class AlarmView extends StatelessWidget {
            final VoidCallback onUpdate;
            const AlarmView({super.key, required this.onUpdate});

            @override
            Widget build(BuildContext context) {
              return Scaffold(
                floatingActionButton: FloatingActionButton(
                  backgroundColor: const Color(0xFF238636),
                  child: const Icon(Icons.alarm_add),
                  onPressed: () => _addAlarm(context),
                ),
                body: ListView.builder(
                  itemCount: AppState.alarms.length,
                  itemBuilder: (ctx, i) {
                    final a = AppState.alarms[i];
                    DateTime dt = DateTime.parse(a['time']);
                    return Card(
                      color: const Color(0xFF161B22),
                      margin: const EdgeInsets.all(10),
                      child: ListTile(
                        leading: Icon(Icons.alarm, color: a['enabled'] ? Colors.blue : Colors.grey),
                        title: Text(DateFormat('yyyy-MM-dd HH:mm').format(dt), style: const TextStyle(color: Colors.white, fontSize: 18)),
                        subtitle: Text(a['message'], style: const TextStyle(color: Colors.grey)),
                        trailing: Switch(
                          value: a['enabled'],
                          onChanged: (val) { a['enabled'] = val; onUpdate(); },
                          activeColor: Colors.green,
                        ),
                        onLongPress: () { AppState.alarms.removeAt(i); onUpdate(); },
                      ),
                    );
                  },
                ),
              );
            }

            void _addAlarm(BuildContext context) async {
              DateTime now = DateTime.now();
              DateTime? d = await showDatePicker(context: context, initialDate: now, firstDate: now, lastDate: DateTime(2030));
              if(d == null) return;
              TimeOfDay? t = await showTimePicker(context: context, initialTime: TimeOfDay.now());
              if(t == null) return;
              
              TextEditingController msgCtrl = TextEditingController(text: "Time up!");
              if(!context.mounted) return;
              
              showDialog(context: context, builder: (ctx) => AlertDialog(
                backgroundColor: const Color(0xFF161B22),
                title: const Text("Alarm Message", style: TextStyle(color: Colors.white)),
                content: TextField(controller: msgCtrl, style: const TextStyle(color: Colors.white)),
                actions: [
                  TextButton(onPressed: () {
                     DateTime finalTime = DateTime(d.year, d.month, d.day, t.hour, t.minute);
                     AppState.alarms.add({'time': finalTime.toIso8601String(), 'message': msgCtrl.text, 'enabled': true});
                     onUpdate();
                     Navigator.pop(ctx);
                  }, child: const Text("Set Alarm", style: TextStyle(color: Colors.green))),
                ],
              ));
            }
          }
          EOF

      - name: Build and Sign APK
        run: |
          # 1. Generate Keystore
          keytool -genkey -v -keystore android/app/release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key -storepass titan123456 -keypass titan123456 -dname "CN=Titan, O=Dev, C=BD"
          
          # 2. Create key.properties
          cat > android/key.properties <<EOF
          storePassword=titan123456
          keyPassword=titan123456
          keyAlias=key
          storeFile=release-key.jks
          EOF
          
          # 3. Modify build.gradle
          cat > android/app/build.gradle <<EOF
          plugins {
              id "com.android.application"
              id "kotlin-android"
              id "dev.flutter.flutter-gradle-plugin"
          }

          def keystoreProperties = new Properties()
          def keystorePropertiesFile = rootProject.file('key.properties')
          if (keystorePropertiesFile.exists()) {
              keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
          }

          android {
              namespace "com.titanchart.titanchart_pro"
              compileSdkVersion 34 
              ndkVersion flutter.ndkVersion

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
              kotlinOptions { jvmTarget = '1.8' }
              sourceSets { main.java.srcDirs += 'src/main/kotlin' }

              defaultConfig {
                  applicationId "com.titanchart.titanchart_pro"
                  minSdkVersion 23
                  targetSdkVersion 34
                  versionCode 1
                  versionName "1.0"
              }

              signingConfigs {
                  release {
                      storeFile file('release-key.jks')
                      storePassword 'titan123456'
                      keyAlias 'key'
                      keyPassword 'titan123456'
                  }
              }
              buildTypes {
                  release {
                      signingConfig signingConfigs.release
                      minifyEnabled false
                      shrinkResources false
                  }
              }
          }
          flutter { source '../..' }
          EOF
          
          # Fix settings.gradle
          cat > android/settings.gradle <<EOF
          pluginManagement {
              def flutterSdkPath = {
                  def properties = new Properties()
                  file("local.properties").withInputStream { properties.load(it) }
                  def flutterSdkPath = properties.getProperty("flutter.sdk")
                  assert flutterSdkPath != null, "flutter.sdk not set in local.properties"
                  return flutterSdkPath
              }()
              includeBuild("\$flutterSdkPath/packages/flutter_tools/gradle")
              repositories { google(); mavenCentral(); gradlePluginPortal() }
          }
          plugins {
              id "dev.flutter.flutter-plugin-loader" version "1.0.0"
              id "com.android.application" version "7.3.0" apply false
              id "org.jetbrains.kotlin.android" version "1.7.10" apply false
          }
          include ":app"
          EOF

          flutter build apk --release

      - name: Upload Final APK
        uses: actions/upload-artifact@v4
        with:
          name: TitanChart-Pro-Final-APK
          path: build/app/outputs/flutter-apk/app-release.apk
